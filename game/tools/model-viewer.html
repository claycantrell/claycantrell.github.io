<!DOCTYPE html>
<html>
<head>
    <title>Model Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; }
        canvas { display: block; }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: monospace;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }
        #controls select, #controls button {
            background: #333;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            margin: 5px 0;
            cursor: pointer;
            font-family: monospace;
        }
        #controls button:hover { background: #0f0; color: #000; }
        #info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #666;
            font-family: monospace;
            font-size: 12px;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-family: monospace;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading game scripts...</div>
    <div id="controls" style="display:none;">
        <b>MODEL VIEWER</b><br><br>
        <select id="modelSelect">
            <option value="knight">Knight</option>
            <option value="test">Test Character</option>
            <option value="cow">Cow</option>
            <option value="deer">Deer</option>
            <option value="bunny">Bunny</option>
            <option value="bird">Bird</option>
        </select>
        <br>
        <button onclick="loadModel()">Load Model</button>
        <button onclick="toggleWireframe()">Wireframe</button>
        <button onclick="toggleRotate()">Auto-Rotate</button>
        <br><br>
        <small>Drag: Orbit | Scroll: Zoom | Right-drag: Pan</small>
    </div>
    <div id="info">Three.js Model Viewer - Using actual game models</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Make THREE global so game scripts can use it
        window.THREE = THREE;

        // ============================================
        // STUB FUNCTIONS FOR GAME SCRIPTS
        // These replace game-specific functions that don't exist in the viewer
        // ============================================

        // Terrain height - just return 0 in viewer
        window.getTerrainHeight = () => 0;

        // Shadow enabling - we'll do it ourselves
        window.enableShadows = (group) => {
            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        };

        // Scene adding - no-op, we add manually
        window.addToScene = () => {};

        // Entity object creation - just return the group
        window.createEntityObject = (id, group, x, y, z, extras) => {
            return { id, group, ...extras };
        };

        // Entity list getter - return empty array
        window.getEntityList = () => [];

        // Entity system creation - no-op
        window.createEntitySystem = () => ({});

        // Config getter - return minimal config
        window.getConfigSafe = (type) => ({
            heightOffset: 0.4,
            collisionRadius: 1
        });

        // Export globals - no-op
        window.exportEntityGlobals = () => {};

        // GAME namespace stub
        window.GAME = {
            scene: null,
            characterParts: null,
            characterType: 'knight'
        };

        // ============================================
        // SCENE SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        window.GAME.scene = scene;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);

        const directional = new THREE.DirectionalLight(0xffffff, 1);
        directional.position.set(5, 10, 5);
        directional.castShadow = true;
        scene.add(directional);

        // Ground plane
        const groundGeo = new THREE.PlaneGeometry(20, 20);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid helper
        const grid = new THREE.GridHelper(20, 20, 0x444466, 0x333355);
        scene.add(grid);

        let currentModel = null;
        let wireframeMode = false;

        // ============================================
        // LOAD ACTUAL GAME SCRIPTS
        // ============================================
        const gameScripts = [
            '../engine/utils/character-types.js',
            '../systems/entities/deer.js',
            '../systems/entities/cow.js',
            '../systems/entities/bunny.js',
            '../systems/entities/bird.js'
        ];

        async function loadGameScripts() {
            for (const src of gameScripts) {
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = () => {
                        console.warn(`Failed to load ${src}, continuing...`);
                        resolve(); // Continue even if one fails
                    };
                    document.body.appendChild(script);
                });
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('controls').style.display = 'block';

            // Load default model
            loadModel();
        }

        // ============================================
        // MODEL LOADING
        // ============================================
        window.loadModel = function() {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }

            const type = document.getElementById('modelSelect').value;
            let model = null;

            // Use the actual game functions
            switch(type) {
                case 'knight':
                    if (typeof createKnightCharacter === 'function') {
                        model = createKnightCharacter();
                    }
                    break;
                case 'test':
                    if (typeof createTestCharacter === 'function') {
                        model = createTestCharacter();
                    }
                    break;
                case 'cow':
                    if (typeof createCow === 'function') {
                        const result = createCow('viewer-cow', 0, 0);
                        model = result.group || result;
                    }
                    break;
                case 'deer':
                    if (typeof createDeer === 'function') {
                        const result = createDeer('viewer-deer', 0, 0);
                        model = result.group || result;
                    }
                    break;
                case 'bunny':
                    if (typeof createBunny === 'function') {
                        const result = createBunny('viewer-bunny', 0, 0);
                        model = result.group || result;
                    }
                    break;
                case 'bird':
                    if (typeof createBird === 'function') {
                        const result = createBird('viewer-bird', 0, 0);
                        model = result.group || result;
                    }
                    break;
            }

            if (model) {
                // Reset position for viewer
                model.position.set(0, 0, 0);

                // Enable shadows
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                currentModel = model;
                scene.add(currentModel);

                // Auto-adjust camera target based on model size
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                controls.target.copy(center);
                controls.update();
            } else {
                console.error(`Failed to create model: ${type}`);
            }
        };

        window.toggleWireframe = function() {
            wireframeMode = !wireframeMode;
            if (currentModel) {
                currentModel.traverse(child => {
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.wireframe = wireframeMode);
                        } else {
                            child.material.wireframe = wireframeMode;
                        }
                    }
                });
            }
        };

        window.toggleRotate = function() {
            controls.autoRotate = !controls.autoRotate;
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        animate();
        loadGameScripts();
    </script>
</body>
</html>
